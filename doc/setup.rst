Setup
=====

IdProxy is based on pysaml2 and pyoidc.

If you are planning on using IdProxy as a IdP frontend a good place to start is reading the documentation for pysaml2
and getting the examples to work. ::

    https://dirg.org.umu.se/page/pysaml2

In the case you want to have an OP frontend you should read and test the examples in pyoidc. ::

    https://github.com/rohe/pyoidc

In general when setting up a proxy it is a good practice to make sure your SP can talk to your IdP and your RP is
talking to your OP, before adding the proxy to the calculation.

You can configure everything manually, but it is recommended to always use the quick setup to get all the basics and then perform your changes.

Quick setup
-----------

IdProxy have a quick setup script that will help you with the basic setup. Go to your IdProxy install folder and run: ::
    ./quicksetup.py

Here follows an example of a quicksetup for a transperant proxy that will forward the certificate enbedded in the
element SPCertEncType from the calling SP to the underlying IdP. The proxy will in this setup forward the assertion
from the IdP directly to the calling SP. The proxy will demand that authn requests and responses are signed.
Be aware that when an assertion is sent unchanged through the proxy the SP must accept that the source for the
assertion differ from the proxy. ::

    ./quicksetup.py
    This script will help you to perform the basic configurations needed to get up and running. (Press enter)
    Port for the server:8999
    Write True to activate HTTPS:True
    Your host (use localhost for testing):myhost.com
    Type Yes to setup a proxy or No(default) to the OP and Idp with only password verification:Yes
    Type Yes(Y) for a quick setup of a proxy anonymizer based encrypted assertion.Yes
    Type Yes to add password verification for using the proxy, otherwise No:No
    (The proxy also support CAS, Yubikey, LDAP etc... but the quick setup do NOT!)
    Url (must begin with http) or path to metadata file contaning all IdP's that should be behind the proxy:http://somehost.com/metadata
    Do you have multiple IdP's behind the proxy, answer Yes or No:No
    The proxy supports WAYF but not the quick setup.
    Url (must begin with http) or path to metadata file contaning all SP's that should make use of the proxy:http://somehost.com:8087/metadata
    Type the information for all server certificates; https, sp and idp.
    Country code(2 letters):se
    State:ac
    City:Umea
    Organisation:ITS
    Organisation unit:DIRG

This script will generate the files test_idp_conf.py , test_op_conf.py, test_sp_conf.py and test_server_conf.py.
You must rename the file test_server_conf.py to server_conf.py. It is also recommended to rename all the other files: ::

    sudo cp test_idp_conf.py idp_conf.py
    sudo cp test_op_conf.py op_conf.py
    sudo cp test_server_conf.py server_conf.py
    sudo cp test_sp_conf.py sp_conf.py

The server is now good to go, but you first have to add the metadata for the server to the SP's and IdP's that are
going to use the proxy. You can use the pysaml2 script make_metadata.py or get the metadata directly from the
IdProxy server. ::

    http://myhost.com:8999/sp_metadata
    http://myhost.com:8999/idp_metadata

Manual setup
------------
IdProxy have 4 configuration files.

server_conf.example
^^^^^^^^^^^^^^^^^^^
Contains general configurations for the server and must be renamed to server_conf.py.

`Click here to view the example file. <https://github.com/its-dirg/IdProxy/blob/master/server_conf.example>`_

All configuration parameters are described with comments in the file, but you will find a lite more
information on this page.

PORT
""""
Port for the webserver.

HTTPS
"""""
True if HTTPS should be used, false is equal to HTTP.

HOST
""""
The hostname of the server. Can be the server IP.

BASEURL
"""""""
The url to the server without port. Depends on HOST and HTTPS.

ISSUER
""""""
Full URL to the server including port.

LOG_FILE
""""""""
Points out the main log file for IdProxy. If you get an error displayed in the browser with an uuid, search in this
file for the displayed uuid to get the matching error.

IDP_FRONTEND
""""""""""""
Set to true if the proxy should act as an SAML IdP.

OP_FRONTEND
"""""""""""
Set to true if the proxy should act as an OpenId Connect provider.

SERVER_CERT
"""""""""""
Must point at a valid certificate. No certificates are shipped with the software you have to create your own or use
quicksetup.py. The default folder is created by quicksetup.py.

SERVER_KEY
""""""""""
Must point at the private key for the certificate in the parameter SERVER_CERT. Default folder and key file is
generated by quicksetup.py.

CERT_CHAIN
""""""""""
Certificate chains is only used by CA certificates and not self signed certificates that the quicksetup.py generates.
If you have a CA created cert the add your certificate chain here.

SESSION_OPTS
""""""""""""
This is a configuration parameter for Beaker Sessions. To understand more about how to configure the session object
please read:
http://beaker.readthedocs.org/en/latest/index.html

idp_conf.example
^^^^^^^^^^^^^^^^
Contains configuration for the frontend SAML IdP. Should be renamed to idp_conf.py or equal.

`Click here to view the example file. <https://github.com/its-dirg/IdProxy/blob/master/idp_conf.example>`_

All configuration parameters are described in the file.

Here follows some extended information about the more complex configurations.

xmlsec_path
"""""""""""
You must verify that you have a correct full path to the xmlsec binary in your system or you will get some hard traced
errors.

BASE
""""
Do not change! Must be the full URL including port, defined in server_conf.example.

FULL_PATH
"""""""""
Must point to the complete path on disk to this file! Needed by the script create_metadata.sh and the IdP to find all
configurations. No need to change this!

WORKING_DIR
"""""""""""
This is the directory for the IdP.

YUBIKEY_SERVER
""""""""""""""
Points to the yubikey validation server. The default value points at yubico's own server. You can point at any yubikey
validation server, for example pyYubitool.

YUBIKEY_DB
""""""""""
If you want to use Yubikey as a authentication method you have to point out a database containing information about
the valid yubikeys.

To create a database use this script: ::

    https://github.com/HaToHo/pyYubitool/blob/master/db/pyYubitool_dbsetup.py

You should also learn about yubikey: ::
    https://www.yubico.com

You will also need to install: ::
    http://www.yubico.com/products/services-software/personalization-tools/

SYM_KEY
"""""""
Symetric key for the IdP server. Any phrase will work, but it must be 16 characters! You must change this key!

CAS_SERVER
""""""""""
URL to your CAS server if you wish to perform a CAS authentication.

CACHE_1 and CACHE_2
"""""""""""""""""""
Two internal caches.

As default a dictionary that only works in a single server solution. If your are using a distributed environment you
should use a database or file representation for the dictionary implementation.

An example of a database dictionary is Sqllite3Dict(WORKING_DIR + "idp_cache1.sqlite3").

AUTHORIZATION
"""""""""""""
This parameter describes how the proxy will authorize users. The proxy can authorize the user with SAML, CAS, Yubikey,
password or with a chain of authentications. The authorization object is a dictionary where the key defines the
authorization method. Each key points at a dictionary that defines the SAML authentication class to be associated
with the method, weight, base url for the response and where user information can be collected.
**USER_INFO** defines how the user information will be collected. The value for USER_INFO must be an instance of the
class DictionaryInformation, an the instance of a the class that implements the same methods or None. Right now is None
only supported by the SAML ACR value. In that case a SAML authentication is used, and the USER_INFO is none the proxy
will forward the information from the underlying IdP. For an example how to use a LDAP or simple dictionary for
collection user information, view the idp_conf.example file.

**URL** should always be `BASE`. **WEIGHT** will order the diffrent authorization methods with the same value of ACR.
This is not fully tested and therefore is it recommended to only use one value for each ACR value.

The following keys exists:
* SAML
    This is make your proxy work as a SAML to SAML proxy. You must use SAML as stand alone or as a part of the
    MULTIPLEAUTHN authorization key. By defining SAML in the dictionary you will activate the Service Provider
    configured in the sp_conf.example file.
* CAS
    This will make your proxy work as a SAML to CAS proxy. For this authorization to work you must have a correct value
    in the CAS_SERVER parameter.
* YUBIKEY
    Will use username/yubikey for authorization with out any proxy functionality. YUBIKEY_SERVER och YUBIKEY_DB must
    be configured.
* PASSWORD
    Will use username/password for authorization with out any proxy functionality.
* PASSWORD_YUBIKEY
    Will use username/yubikey/password for authorization with out any proxy functionality.
* MULTIPLEAUTHN
    If you want to add yubikey authorization to your CAS or SAML IdP server you can use MULTIPLEAUTHN or just create an
    SAML to CAS to SAML proxy. This key contains one additional parameter in the sub dictionary; AUTHNLIST. ::
        "AUTHNLIST": [
        {"ACR": "PASSWORD_YUBIKEY"},
        {"ACR": "CAS"},
        {"ACR": "SAML"}
        ]
    You list all authorizations that should take place when calling the proxy and the order matters.
    In the example above the user will have to login with username/yubike/password, then be authenticated at a
    CAS server and an designated IdP. You should always have SAML last in the list, to retrive the user information
    from the IdP. The last value in the list is always used to determine how the information about the user is
    collected.

COPYSPCERT
""""""""""
True if you want to copy the certificate from the calling SP and add it to the call to the underlying SAML IdP.
The authn request from the proxy to an underlying IdP cannot be signed if this value is true!
Only useful if SAML authorization is activated.

COPYSPKEY
"""""""""
True if you want to copy the encryption certificate from the calling SP and add it to the call to the underlying SAML
IdP. Only useful if SAML authorization is activated.

USERS
"""""
User database as a dictionary. These are the keys and values returned in the assertion if no underlying IdP is used.
You can use a database instead as long as it has a dictionary interface, like Sqllite3Dict and that you have the
same structure of the database as the dictionary in the example.

EXTRA
"""""
Extra information about the user.

PASSWD
""""""
Username as key and password as value. This dictionary is used for username/password validations.
You can use a database instead as long as it has a dictionary interface, like Sqllite3Dict and that you have the
same structure of the database as the dictionary in the example.

CONFIG
""""""
This is a pysaml2 configuration dictionary and you should read the pysaml2 documentation to understand it.

https://dirg.org.umu.se/page/pysaml2

I will give some hints on good to know parameters.

Here follows some configurations that can be used directly in the config dictionary:

* Only use keys in metadata
    True if the metadata specified certificates for signatures always must be used.
    False if the metadata specified certificates for signatures is prefered,
    but it is also allowed to use the signature certificates in the authn request. ::

    "only_use_keys_in_metadata": False,

* Generate certificates for signature
    To generate certificates for signatures for each call you have to add keys for generate_cert_info,
    tmp_key_file and tmp_cert_file. You can add a generation algorithm in the cert_handler_extra_class parameter,
    or use key_file and cert_file as root certificates. key_file and cert_file must always point at a valid certificate
    and key pair. If cert_handler_extra_class is None the key_file and cert_file will be used as root certificates
    for generating new certificates. If you want to apply your own algorithm to generate new certificates you should
    extend the class CertHandlerExtra in pysaml2. The cert_handler_extra_class must then point at an instance of your
    class. The settings must be inserted on the same place as you find the comment #CERT_GENERATION in the
    idp_conf.example file. ::

        "cert_handler_extra_class": None,
        "generate_cert_info": {
            "cn": BASE,
            "country_code": "se",
            "state": "ac",
            "city": "Umea",
            "organization": "ITS Umea University",
            "organization_unit": "DIRG"
        },
        "tmp_key_file": WORKING_DIR + "idp_cert/tmp_mykey.pem",
        "tmp_cert_file": WORKING_DIR + "idp_cert/tmp_mycert.pem",
        "validate_certificate": True,

* Signing the authn response.
    If you want your IdP to sign the authn request response. You can add sign_response to your idp configuration. ::

    "sign_response": True

* Enrtypt assertion.
    If you want the proxy to encrypt the assertion, you can add encrypt_assertion to the idp configuration.
    This will have no effect if COPY_ASSERTION = True for the proxy SP configuration. ::

    "encrypt_assertion": True,

sp_conf.example
^^^^^^^^^^^^^^^^

`Click here to view the example file. <https://github.com/its-dirg/IdProxy/blob/master/sp_conf.example>`_

All configuration parameters are described in the file.

Here follows some extended information about the more complex configurations.

xmlsec_path
"""""""""""
You must verify that you have a correct full path to the xmlsec binary in your system or you will get some hard traced
errors.

DISCOSRV
""""""""
Url to a discovery server for SAML. None implies not using one.

WAYF
""""
Url to a wayf for SAML. None implies not using one.

PORT
""""
Port for the webserver. Must be same as server_conf.example.

HTTPS
"""""
True if HTTPS should be used, false is equal to HTTP. Must be same as server_conf.example.

HOST
""""
The hostname of the server. Can be the server IP. Must be same as server_conf.example.

BASEURL
"""""""
The url to the server without port. Depends on HOST and HTTPS. Must be same as server_conf.example.

ISSUER
""""""
Full URL to the server including port. Must be same as server_conf.example.

BASE
""""
Full URL to the server including port.

DISCOENDPOINT
"""""""""""""
This is the url where the Service Provider expects to get the response from the discovery server.
There is no need to change this value.

SPVERIFYBASE
""""""""""""
The base url for the SP at the server.

SPVERIFYBASEIDP
"""""""""""""""
The base url for verification of the response from a IdP.

ASCREDIRECT
"""""""""""
The BASE url where the Idp performs the redirect after a authn request from the SP.
For the cookies to work do not use subfolders.

ASCPOST
"""""""
The BASE url where the Idp performs a post after a authn request from the SP.
For the cookies to work do not use subfolders.

ASCVERIFYPOSTLIST
"""""""""""""""""
Regual expression to match a post from Idp to SP.

ASCVERIFYREDIRECTLIST
"""""""""""""""""""""
Regual expression to match a redirect from Idp to SP.

FULL_PATH
"""""""""
Must point to the complete path on disk to this file!
Needed by the script create_metadata.sh and the SP to find all configurations.
No need to change this!

WORKING_DIR
"""""""""""
This is the directory for the SP.

CACHE
"""""
A shared server cache for the IdP. The cache expects a dictionary, but you can use a database by implementing the
dictionary interface.

COPY_ASSERTION
""""""""""""""
Set this value to true if you want to copy the assertion from the IdP to the SP without any changes by the proxy.
For example if the assertion is encrypted with a key that from the SP you have to copy the complete assertion.
This is a special case and the normal value is false!
If you copy the assertion the SP must be aware that the assertion will not contain the same destination information as
the response.

CERT_TIMEOUT
""""""""""""
The amount of time in minutes an SP cert will be saved in the cache.

ANONYMIZE
"""""""""
True if you want to anonymize the assertion. If COPY_ASSERTION is true this flag is of no use.

ANONYMIZE_SALT
""""""""""""""
This salt is the key to perform a more secure anonymize service.
YOU SHOULD NEVER USE THE DEFAULT VALUE! Please change this!

OPENID2SAMLMAP
""""""""""""""
This is a map for Open Id connect to Saml2. The proxy will give the same response for OAuth2.

CONFIG
""""""
Traditional pysaml2 configuration for a SP. View more documentation for pysaml2.

https://dirg.org.umu.se/page/pysaml2


Here follows some parameters that are good to know for the proxy.

* Sign the reqeust from the proxy SP.
    Add the authn_request_signed parameter to the sp configuration to sign the authn request from the proxy sp. ::

        "authn_requests_signed": "true",

* Demand that the assertion from the IdP is signed.
    Add the want_assertions_signed parameter to the sp configuration to make the proxy reject all assertions that are
    not signed. ::

        "want_assertions_signed": "true",

* Demand that the response from the IdP is signed.
    Add the want_response_signed parameter to the sp configuration to make the proxy reject all responses that are not
    not signed. ::

        "want_response_signed": "true",

VALID_ATTRIBUTE_RESPONSE
""""""""""""""""""""""""
A dictionary that contains SAML response attributes that must be returned from the IdP for the user to be authenticated.
The value for the key should be None if all values are allowed, or a list of strings containing the approved values to be
returned. Set VALID_ATTRIBUTE_RESPONSE to None if it should not be used.

The verification of values will be approved if the given string is a substring of the returned value.

Example::

    VALID_ATTRIBUTE_RESPONSE = {
        "eduPersonAffiliation": ["student"],
        "eduPersonScopedAffiliation": ["student"]
    }

ATTRIBUTE_WHITELIST
"""""""""""""""""""
A dictionary where the keys are all the SAML attributes that may be returned by the proxy front end. The value for
the key represents what a attibute value must contain to be valid. If the key value is none all attribute values are
valid.
Set VALID_ATTRIBUTE_RESPONSE to None if all attributes from the underlying IdP should be returned.

The verification of values will be approved if the given string is a substring of the returned value.

Example::

    ATTRIBUTE_WHITELIST = {
        "eduPersonScopedAffiliation": ["student"]
    }

op_conf.example
^^^^^^^^^^^^^^^^

`Click here to view the example file. <https://github.com/its-dirg/IdProxy/blob/master/op_conf.example>`_

All configuration parameters are described in the file.

Here follows some extended information about the more complex configurations.

PORT
""""
Port for the webserver. Must be same as server_conf.example.

HTTPS
"""""
True if HTTPS should be used, false is equal to HTTP. Must be same as server_conf.example.

HOST
""""
The hostname of the server. Can be the server IP. Must be same as server_conf.example.

BASEURL
"""""""
The url to the server without port. Depends on HOST and HTTPS. Must be same as server_conf.example.

ISSUER
""""""
Full URL to the server including port. Must be same as server_conf.example.

CAS_SERVER
""""""""""
URL to your CAS server if you wish to perform a CAS authentication.

CAS_SERVICE_URL
"""""""""""""""
The response URL to this server from the CAS server. No need to change the value.

AUTHORIZATION
"""""""""""""
This parameter describes how the proxy will authorize users. The proxy can authorize the user with SAML, CAS, Yubikey,
password or with a chain of authentications. The authorization object is a dictionary where the key defines the
authorization method. Each key points at a dictionary that defines the acr value for the authentication method, weight,
base url for the response and where user information can be collected.

| Example:
::

    AUTHORIZATION = {
        "SAML": {"ACR": "SAML", "WEIGHT": 3, "URL": ISSUER, "USER_INFO": "SAML"},
        "CAS": {"ACR": "CAS", "WEIGHT": 2, "URL": ISSUER, "USER_INFO": "LDAP"},
        "YUBIKEY": {"ACR": "YUBIKEY", "WEIGHT": 1, "URL": ISSUER, "USER_INFO": "SIMPLE"},
        "PASSWORD": {"ACR": "PASSWORD", "WEIGHT": 1, "URL": ISSUER, "USER_INFO": "SIMPLE"},
        "PASSWORD_YUBIKEY": {"ACR": "PASSWORD_YUBIKEY", "WEIGHT": 1, "URL": ISSUER, "USER_INFO": "SIMPLE"},
        "MULTIPLEAUTHN": {
            "ACR": "MultipleAuthnTest",
            "WEIGHT": 4,
            "URL": ISSUER,
            "USER_INFO": "SAML",
            "AUTHNLIST": [
                {"ACR": "PASSWORD"},
                {"ACR": "CAS"},
               {"ACR": "SAML"}
            ]

        }
    }


The following authorization keys exists:
* SAML
    This is make your proxy work as a OP to SAML proxy. You must use SAML as stand alone or as a part of the
    MULTIPLEAUTHN authorization key. By defining SAML in the dictionary you will activate the Service Provider
    configured in the sp_conf.example file.
* CAS
    This will make your proxy work as a SAML to CAS proxy. For this authorization to work you must have a correct value
    in the CAS_SERVER parameter.
* YUBIKEY
    Will use username/yubikey for authorization without any proxy functionality. YUBIKEY_SERVER och YUBIKEY_DB must
    be configured.
* PASSWORD
    Will use username/password for authorization with out any proxy functionality.
* PASSWORD_YUBIKEY
    Will use username/yubikey/password for authorization with out any proxy functionality.
* MULTIPLEAUTHN
    If you want to add yubikey authorization to your CAS or SAML IdP server you can use MULTIPLEAUTHN or just create an
    OP to CAS to SAML proxy. This key contains one additional parameter in the sub dictionary; AUTHNLIST. ::
        "AUTHNLIST": [
        {"ACR": "PASSWORD_YUBIKEY"},
        {"ACR": "CAS"},
        {"ACR": "SAML"}
        ]
    You list all authorizations that should take place when calling the proxy and the order matters.
    In the example above the user will have to login with username/yubike/password, then be authenticated at a
    CAS server and an designated IdP. You should always have SAML last in the list, to retrive the user information
    from the IdP.
| WEIGHT defines the weight between the authentication methods.
| URL used internally to define the URL that handles the authentication method. Just leave it with ISSUER.
| The following USER_INFO values can be used:
* SAML
    Only useful for acr value SAML. User information is collected from the underlying IdP.
* LDAP
    User information is collected from a LDAP server. LDAP and LDAP_EXTRAVALIDATION must be configured correctly.
* SIMPLE
    User infromation is collected from the dictionary defined in the configuration parameter USERDB.


FULL_PATH
"""""""""
Must point to the complete path on disk to this file! No need to change this!

WORKING_DIR
"""""""""""
Must point to the complete path on disk to this file and end with a slash.

OP_CACHE_1 and OP_CACHE_2
"""""""""""""""""""""""""
Two internal caches.

As default a dictionary that only works in a single server solution. If your are using a distributed environment you
should use a database or file representation for the dictionary implementation.

An example of a database dictionary is Sqllite3Dict(WORKING_DIR + "idp_cache1.sqlite3").

YUBIKEY_SERVER
""""""""""""""
Points to the yubikey validation server. The default value points at yubico's own server. You can point at any yubikey
validation server, for example pyYubitool.

YUBIKEY_DB
""""""""""
If you want to use Yubikey as a authentication method you have to point out a database containing information about
the valid yubikeys.

To create a database use this script: ::

    https://github.com/HaToHo/pyYubitool/blob/master/db/pyYubitool_dbsetup.py

You should also learn about yubikey: ::
    https://www.yubico.com

You will also need to install: ::
    http://www.yubico.com/products/services-software/personalization-tools/

AUTHORIZATIONPAGE_PASSWORD
""""""""""""""""""""""""""
The page in mako/htdocs that will handle user/password login.

AUTHORIZATIONPAGE_YUBIKEY
"""""""""""""""""""""""""
The page in mako/htdocs that will handle user/yubikey login.

AUTHORIZATIONPAGE_PASSWORD_YUBIKEY
""""""""""""""""""""""""""""""""""
The page in mako/htdocs that will handle user/password/yubikey login.

SYM_KEY
"""""""
Symetric key for the OP server. Any phrase will work, but it must be 16 characters! You must change this key!

LOG_FILE
""""""""
Filename for OP server log.

COOKIENAME
""""""""""
The pyoidc based op server uses cookies to maintain a session. This is is the name of that cookie.

COOKIETTL
"""""""""
Time to live for the cookie.

OP_PRIVATE_KEYS
"""""""""""""""
Private RSA key for the provider. ::

    OP_PRIVATE_KEYS = {
        "rsa": {
            #Your RSA PEM PRIVATE KEY
            "key": "opKeys/localhost.key",
            #enc = Encryption and sig = Signature
            "usage": ["enc", "sig"]
        }
    }

OP_PUBLIC_KEYS
""""""""""""""
Path for the public RSA key for the provider. You can use certgeneration.py to provide you with a correct file.
For more information read: http://openid.net/specs/draft-jones-json-web-key-03.html

LDAP
""""
Configuration for your LDAP server. ::

    LDAP = {
        "uri": "ldap://my.ldap.com",
        "base": "dc=umu, dc=se",
        "filter_pattern": "(uid=%s)",
        "user": "",
        "passwd": "",
        "attr": ["eduPersonScopedAffiliation", "eduPersonAffiliation"],
    }

LDAP_EXTRAVALIDATION
""""""""""""""""""""
Verifies the result in one or more attributes.

| For example:
::

    LDAP_EXTRAVALIDATION = {
        "verify_attr": "eduPersonAffiliation",
        "verify_attr_valid": ['employee', 'staff', 'student']
    }

Verifies that eduPersonAffiliation contains one of the values employee, staff or student.

PASSWD
""""""
Username as key and password as value. This dictionary is used for username/password validations.
You can use a database instead as long as it has a dictionary interface, like Sqllite3Dict and that you have the
same structure of the database as the dictionary in the example.

USERDB
""""""
User database as a dictionary. These are the keys and values returned from the OP the RP.
You can use a database instead as long as it has a dictionary interface, like Sqllite3Dict and that you have the
same structure of the database as the dictionary in the example.



